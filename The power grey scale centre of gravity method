##### import cv2
import numpy as np
import matplotlib.pyplot as plt
import ipywidgets as widgets
import pandas as pd
from IPython.display import display, clear_output
from tqdm.notebook import tqdm  # âœ… è¿›åº¦æ¡

# å¯ç”¨ Matplotlib äº¤äº’æ¨¡å¼
%matplotlib widget  

# è¯»å– MP4 è§†é¢‘
video_path = "F POWER is 0.60.avi"
output_video_path = video_path.replace(".avi", "_processed.avi")

cap = cv2.VideoCapture(video_path)

# è·å–è§†é¢‘ä¿¡æ¯
frame_width = int(cap.get(3))
frame_height = int(cap.get(4))
fps = int(cap.get(cv2.CAP_PROP_FPS))
frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

# åˆå§‹åŒ–è§†é¢‘å†™å…¥å™¨
fourcc = cv2.VideoWriter_fourcc(*'XVID')  
out = cv2.VideoWriter(output_video_path, fourcc, fps, (frame_width, frame_height))

# è®°å½•åœ†å¿ƒæ•°æ®
circle_data = []

# è¯»å–ç¬¬ä¸€å¸§ä»¥é€‰æ‹© ROI
ret, first_frame = cap.read()
cap.set(cv2.CAP_PROP_POS_FRAMES, 0)  # é‡ç½®å¸§ä½ç½®

if not ret:
    print("æ— æ³•è¯»å–è§†é¢‘")
    cap.release()
else:
    h_img, w_img, _ = first_frame.shape
    x_init, y_init, w_init, h_init = 130, 50, 270, 270  # åˆå§‹ ROI

    # **åˆ›å»ºæ»‘å—**
    x_slider = widgets.IntSlider(min=0, max=w_img-50, value=x_init, description="X ä½ç½®")
    y_slider = widgets.IntSlider(min=0, max=h_img-50, value=y_init, description="Y ä½ç½®")
    w_slider = widgets.IntSlider(min=20, max=w_img, value=w_init, description="å®½åº¦")
    h_slider = widgets.IntSlider(min=20, max=h_img, value=h_init, description="é«˜åº¦")
    confirm_button = widgets.Button(description="ç¡®è®¤ ROI")

    # **åˆ›å»º Matplotlib ç”»å¸ƒ**
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.imshow(cv2.cvtColor(first_frame, cv2.COLOR_BGR2RGB))
    roi_rect = plt.Rectangle((x_init, y_init), w_init, h_init,
                             linewidth=2, edgecolor='r', facecolor='none')
    ax.add_patch(roi_rect)
    ax.set_title("è°ƒæ•´æ»‘å—é€‰æ‹© ROI")

    def update_rect(*args):
        """æ›´æ–°çŸ©å½¢æ¡†"""
        roi_rect.set_xy((x_slider.value, y_slider.value))
        roi_rect.set_width(w_slider.value)
        roi_rect.set_height(h_slider.value)
        fig.canvas.draw_idle()  # **å¼ºåˆ¶åˆ·æ–° Matplotlib**

    # **ç›‘å¬æ»‘å—å˜åŒ–**
    x_slider.observe(update_rect, names='value')
    y_slider.observe(update_rect, names='value')
    w_slider.observe(update_rect, names='value')
    h_slider.observe(update_rect, names='value')

    display(x_slider, y_slider, w_slider, h_slider, confirm_button)

    def process_video(b):
        """å¤„ç†æ•´ä¸ªè§†é¢‘ï¼Œå¹¶æ˜¾ç¤ºè¿›åº¦æ¡"""
        clear_output(wait=True)
        display(x_slider, y_slider, w_slider, h_slider, confirm_button)

        x, y, w, h = x_slider.value, y_slider.value, w_slider.value, h_slider.value
        print(f"å¼€å§‹å¤„ç†è§†é¢‘ï¼Œæ¯å¸§ROI: ({x}, {y}, {w}, {h})")

        cap.set(cv2.CAP_PROP_POS_FRAMES, 0)  # é‡ç½®åˆ°ç¬¬ä¸€å¸§
        frame_idx = 0

        # **æ·»åŠ è¿›åº¦æ¡**
        progress = tqdm(total=frame_count, desc="Processing Video", unit="frame")

        while cap.isOpened():
            ret, frame = cap.read()
            if not ret:
                break

            # **å›¾åƒå¤„ç†**
            image_no_red = frame.copy()
            image_no_red[:, :, 2] = 0  # å»æ‰çº¢è‰²é€šé“
            
            green_scale = 0.7  # ä¾‹å¦‚å‡å°‘ 20%
            blue_scale = 1   # ä¾‹å¦‚å¢åŠ  20%

            image_no_red[:, :, 1] = (image_no_red[:, :, 1] * green_scale).astype(np.uint8)
            image_no_red[:, :, 0] = (image_no_red[:, :, 0] * blue_scale).astype(np.uint8)
            gray = cv2.cvtColor(image_no_red, cv2.COLOR_BGR2GRAY)
            clahe = cv2.createCLAHE(clipLimit=10.0, tileGridSize=(10, 50))
            gray = clahe.apply(gray)
            blurred = cv2.medianBlur(gray, 5)

            result_frame = frame.copy()
            min_contour_area = 10000  
            max_contour_area = 30000  

            # å¤„ç† ROI
            roi_img = blurred[y:y+h, x:x+w]

            # Otsu é˜ˆå€¼
            _, thresh = cv2.threshold(roi_img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

            # å½¢æ€å­¦ä¿®å¤
            kernel = np.ones((3, 3), np.uint8)
            thresh_fixed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel, iterations=2)

            # è½®å»“æ£€æµ‹
            contours, _ = cv2.findContours(thresh_fixed, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            filtered_contours = [cnt for cnt in contours if min_contour_area < cv2.contourArea(cnt) < max_contour_area]

            if filtered_contours:
                largest_contour = max(filtered_contours, key=cv2.contourArea)
                (cx, cy), radius = cv2.minEnclosingCircle(largest_contour)

                # è½¬æ¢åæ ‡åˆ°å…¨å›¾
                cx, cy = int(cx + x), int(cy + y)

                # ç”»æ‹Ÿåˆåœ†
                cv2.circle(result_frame, (cx, cy), int(radius), (0, 255, 0), 2)
                cv2.circle(result_frame, (cx, cy), 2, (0, 0, 255), 3)

                # è®°å½•åœ†å¿ƒæ•°æ®
                circle_data.append([frame_idx, cx, cy, int(radius)])

            # å†™å…¥æ–°è§†é¢‘
            out.write(result_frame)

            # æ›´æ–°è¿›åº¦æ¡
            progress.update(1)
            frame_idx += 1

        # å…³é—­è¿›åº¦æ¡
        progress.close()

        # é‡Šæ”¾èµ„æº
        cap.release()
        out.release()

        # **ä¿å­˜æ•°æ®ä¸º CSV**
        df = pd.DataFrame(circle_data, columns=["Frame", "X", "Y", "Radius"])
        csv_path = video_path.replace(".avi", "_circle_data.csv")
        df.to_csv(csv_path, index=False)

        print(f"\nâœ… è§†é¢‘å¤„ç†å®Œæˆï¼")
        print(f"ğŸ“‚ å¤„ç†åçš„è§†é¢‘: {output_video_path}")
        print(f"ğŸ“Š è½¨è¿¹æ•°æ® CSV: {csv_path}")

    confirm_button.on_click(process_video)

